from typing import Any
import psycopg2
import psycopg2.extras

import pandas as pd
# 予めpostgreSQLを導入しておく
# https://qiita.com/yorokobi_kannsya/items/f77d074e382a88dae971

# テーブルはターミナルで以下のコマンドにより確認できる
# psql -l

# 存在するテーブルを入力して接続する。なければ予め作成しておくこと。
#コマンドラインで実行する場合は以下のように入力
# psql -U username test_database

class Database():

    def __init__(self):
        conn:Any = psycopg2.connect(" dbname=" + "test_database")
        cur:Any = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)

        #Store
        self.connection = conn
        self.cur = cur

    def create_table(self):
        query = "CREATE TABLE table1 ("
        #文字列型
        query += "varcher_test varchar(6),"     # 6文字以下の文字列
        query += "char_test char(5),"           #　5文字固定の文字列
        query += "str_test text,"               #　stringと同じ
        # 整数データ型
        query += "int2_test smallint,"          #　2byteまでの整数型
        query += "int4_test int,"               #　4byteまでの整数型
        query += "int8_test bigint,"            #　8byteまでの整数型
        # 連番型(AUTO_INCREMENT)、連番で自動格納される
        query += "byte2_auto_add smallserial,"
        query += "byte4_auto_add serial,"
        query += "byte8_auto_add bigserial,"
        # 日付型
        query += "timestamp timestamp,"                     # 1999-01-08 10:23:54
        query += "timestamp_with timestamp with time zone," # 1999-01-08 10:23:54+09(日本標準時間は+09)
        query += "date date,"                               # 1999-01-08
        query += "time time,"                               # 10:23:54
        query += "time_with time with time zone,"            # 10:23:54+09
        # 真偽値型
        query += "bool_name boolean," 
        #ネットワーク型
        query += "cidr_name cidr,"              # 192.168.128.0/24
        query += "inet_name inet,"              # 192.168.128.0/24
        query += "macaddr_name macaddr,"         # マックアドレス：'08:00:2b:01:02:03'

        # 制約設定
        query += "default_test integer default 0," # デフォルト設定(ない場合はNULLが入る)
        query += "nonull_test integer not null," # ヌルを許容しない(NULLの瞬間エラーになる)

        #================================================================
        # Check制約テスト
        #================================================================
        query += "nonullstr_test varchar(10) null," # ヌルを許容する(明示的に記入しただけ)
        query += "check_test integer check(check_test > 0)," # 条件を設定(満たさない場合エラーとなる)
        query += "check_test2 text check(check_test2 <> '')," # ''以外しか受け付けない
        query += """maxpoint integer, 
                    minpoint integer, 
                    check(maxpoint >= minpoint),""" # 複数カラム間でもチェックできる

        #================================================================
        # GENERATED ALWAYS/BY DEFAULT
        #================================================================
        #1から自動で割り振られる。この列に入れようとするとエラー
        #強制上書きは "overriding system value"の追加が必要
        query += "g_always integer generated always as identity," 

        #1から自動で割り振られる。この列に入れようとしてもエラーにならない
        #いれる値を無視して連番に揃えたい場合は"overriding user value"の追加が必要
        query += "g_by_default integer generated by default as identity," 

        # 5飛びで追加することもできる
        query += "g_always_i5 integer generated always as identity (increment by 5)," 

        # 開始も指定可能
        query += "g_always_s50 integer generated always as identity (start with 50)," 

        #組み合わせも可能
        query += "g_always_i5s50 integer generated always as identity (increment by 5 start with 50)," 

        #================================================================
        # UNIQUE
        #================================================================
        # 重複するとエラーになる列を生成。ただしNULLはエラーとならない
        # uniqueを指定すると自動的にインデックスが割り振られる
        query += "unique_name text unique," 

        # 複数のカラムにunique制約を設定できる
        # この場合はAかつBの列で同じものがあれば弾く。(1,5),(3,5)の組み合わせは弾かない！
        # またNULLが入っていたら、これも弾かない
        query += """u_address_a text, 
                    u_address_b text, 
                    unique (u_address_a, u_address_b),"""

        #================================================================
        # PRIMARY KEY
        #================================================================
        # uniqueに加えてNULLも許容しない。さらにテーブルにつき一つのみ！
        query += "primary_name varchar(10) primary key" 

        # 複数のカラムにprimary key制約を設定可能
        # この場合はAかつBの列で同じものがあれば弾く。(1,5),(3,5)の組み合わせは弾かない！
        # またちょっとでもNULLが入りそうならエラー
        query2 = ""
        query2 += """ p_name_a text, 
                    p_name_b text, 
                    primary key(p_name_a, p_name_b)"""

        query += ");"

        cur = self.cur
        cur.execute(query)
        #print(cur.fetchall())

    def create_table_second(self):
        query = "CREATE TABLE table2 ("
        
        #================================================================
        # FOREIGN KEY
        #================================================================
        # 別のテーブルの主キーを参照できる
        # 主キーは「primary_name text」とする,
        
        query += "id integer," 
        query += """
            ref_name text, 
            foreign key (ref_name) references table1(primary_name)""" 
        
        #削除時と更新時の設定も可能
        # 削除時：on delete no action設定すると、primary_name削除時にエラーとなり連鎖削除を防ぐ
        # 更新時：on delete no action設定すると、primary_name更新時にエラーとなり連鎖変更を防ぐ
        query2 = ""
        query2 += """
            ref_name text, 
            foreign key (ref_name) references table1(primary_name)
                on delete no action
                on update no action, """ 

        #削除時と更新時の設定も可能
        # 削除時：cascade設定すると、primary_name削除時に連鎖的にrefも削除する
        # 更新時：cascade設定すると、primary_name更新時に連鎖的にrefの値も変更する
        query3 = ""
        query3 += """
            ref_name text, 
            foreign key (ref_name) references table1(primary_name)
                on delete cascade
                on update cascade, """ 



        query += ");"

        cur = self.cur
        cur.execute(query)

    def create_table_temp(self):
        #================================================================
        # 一時テーブル
        #================================================================
        #セッションが切れると消去されるテーブル。それ以外は同じ挙動。tempキーワードで指定
        query = "CREATE temp TABLE table3 ("
        query += "id integer" 
        query += ");"
        cur = self.cur
        cur.execute(query)

    def create_table_inherits(self):
        #================================================================
        # 継承
        #================================================================
        # 他のテーブルを継承できる。差分を作りたいときに便利。
        query = "CREATE temp TABLE table4 ("
        query += "child_item integer" 
        query += ")inherits(table1);"
        cur = self.cur
        cur.execute(query)

        # ちなみにselect * from 親table でも親子両方が取得される
        query = "select * from table1;"

        #どちらか明記する場合はtableoidをつけてidを表示させる"
        query = "select * tableoid from table1;"

        # ただしidではわかりにくいので名前で分類する場合は
        # システムカタログの pg_classを使って指定する
        query =  """select *, pg_class.relname
            from table1
            join pg_class on pg_class.oid = table1.tableoid;"""

        # 子テーブルの指定はそのままでOK
        query = "select * tableoid from table4;"

        # 親テーブルのみの指定はonlyキーワードをつける
        query = "select * tableoid from only table1;"

        #ちなみに条件の継承はprimary keyとunique以外は継承される
        #ちなみに継承させない場合は「親側」でno inheritをつける
        parent_query = ""
        parent_query += """create table parenttbl (
            num integer check (num4 != 0) no inherit
        );"""

        #　また複数の親から継承できる
        query_many = """CREATE TABLE table_double (
            child_item integer)inherits(table1, table2);"""

        # 最後に、
        # 親のカラム名変更やフィールド変更は子供にも変更時に反映される
        # 逆に子供の変更は親には影響しない


    def create_table_copy(self):
        #================================================================
        # コピー
        #================================================================
        #likeで指定したテーブルを追加してコピーする
        # ただし、テーブル構造だけで中身はコピーされない
        # NotNull以外の制約もコピーされない
        query = """create table table5 (
            billingdate date, 
            like table1
        );"""

        #制約も含めてコピーする場合はinclude制約を追加する
        query = """create table table5 (
            billingdate date, 
            like table1 include indexes
        );"""
        #include制約一覧
        """
        defaults      # default制約もコピー
        identity      # カラムへの IDENTITY の指定がコピー。カラムに割り当てられるシーケンスはコピー元とコピー先で異なります
        constraints   # CHECK 制約がコピーされます
        indexes       # primary key, unique, exclude の各制約もコピー
        comments      # カラム、制約、インデックスに関するコメントもコピー
        statistics    # 拡張統計情報もコピー
        storag        # カラム定義に関するSTORAGE設定もコピー
        ALL           # 全てのオプションを指定したのと同じです
        """

        # 複数のテーブルもコピーして合体できる
        query = """create table table5 (
            like table1,
            like table2,
        );"""

        # またSelectで抽出した要素をそのままテーブルにもできる
        # その場合はasで接続する
        query = """create table myschema.tokyocustomer as 
            select id, name from myschema.customer 
            where address = 'Tokyo'
        ;"""

        # 中身のデータをコピーしない場合はwith no dataをつける
        query = """create table myschema.tokyocustomer as 
            select id, name from myschema.customer 
            where address = 'Tokyo'
            with no data
        ;"""
        

        cur = self.cur
        cur.execute(query)

    def alter(self):
        #================================================================
        # ALTER TABLE
        #================================================================
        # テーブルAをテーブルBに名称変更する
        query = """alter table tableA rename to tableB;"""

        # テーブルAのcolumnAをcolumnBに名称変更する
        query = """alter table tableA rename column columnA to columnB;"""

        cur = self.cur
        cur.execute(query)

    def create_schema(self):
        #スキーマを作成する
        query = "create schema schemaA;"

        # オーナーを指定してスキーマを作成する
        query = "create schema schemaA authorization c;"

        # スキーマAの中にテーブルAを作成する
        query = """create schemas chemaA 
                create table tableA (id integer);"""

        # スキーマAとスキーマBに同じテーブルOがあるとする
        # このとき省略で優先指定できるのをsetで設定できる
        # ただしsetは現在のセッション中のみで一時的
        query = "set search_path to schemaA, schemaB;"

        #恒久的に変更する場合は以下のように設定する
        query = "alter role ownerA set search_path to schemaA, schemaB;"

        # スキーマAをスキーマBに名称変更する
        query = "alter schema schemaA rename to schemaB;"

        # スキーマAの所有者をownerPへ変更する
        query = "alter schema schemaA owner to ownerP;"

        # スキーマAを削除する
        #ただし中にテーブル(オブジェクト)がある場合は削除されない
        query = "drop schema schemaA;"

        #オブジェクトがあっても削除する場合はCascadeをつける
        query = "drop schema schemaA cascade;"

        #ちなみにスキーマを設定しない場合、
        # publicというスキーマへ自動的にテーブルが入っている









    def drop_table(self):
        query = "DROP TABLE table1"
        cur = self.cur
        cur.execute(query)

    def to_dataframe(self, table_name: str):
        return pd.read_sql(sql=f'SELECT * FROM {table_name};', con=self.connection)

    def print(self, table:str):
        df = self.to_dataframe(table)
        print(df)


if __name__ == '__main__':
    
    db = Database()
    db.create_table()
    db.create_table_second()
    db.create_table_inherits()
    #db.drop_table()